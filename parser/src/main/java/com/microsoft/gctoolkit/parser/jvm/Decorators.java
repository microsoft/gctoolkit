// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
package com.microsoft.gctoolkit.parser.jvm;

import com.microsoft.gctoolkit.parser.unified.UnifiedLoggingLevel;
import com.microsoft.gctoolkit.time.DateTimeStamp;

import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

public class Decorators {

    /**
     * This class represents the decorators found in the log line as defined by JEP 158 (https://openjdk.java.net/jeps/158).
     * The list, taken from that document is as:
     * time -- Current time and date in ISO-8601 format
     * uptime -- Time since the start of the JVM in seconds and milliseconds (e.g., 6.567s)
     * timemillis -- The same value as generated by System.currentTimeMillis()
     * uptimemillis -- Milliseconds since the JVM started
     * timenanos -- The same value as generated by System.nanoTime()
     * uptimenanos -- Nanoseconds since the JVM started
     * pid -- The process identifier
     * tid -- The thread identifier
     * level -- The level associated with the log message
     * tags -- The tag-set associated with the log message
     *
     * This implementation takes advantage of the property that the ordering of tags is stable. For example,
     * -Xlog:*::pid,time produces the identical ordering as -Xlog:*::time,pid. Moreover, the list of decorators
     * is dedupped implying that the second decorator in -Xlog:*::time,time is ignored.
     *
     * The default decorators (as of the time of authoring JDK 9-21) include [uptime][level][tags].
     * For example, [1.361s][info][gc,heap]. This reads uptime of 1.361 seconds. The tag for the log record
     * is gc.heap at the info level.
     *
     * At issue is that timemillis and uptimemillis are, on the surface, indistinguishable. The same is true with
     * timenanos and uptimenanos as well as with pid and tid. The following logic can be used to help differentiate
     * indistinguishable decorators.
     *
     * 1) If both decorators are present then order can be used to differentiate
     * 2) If ms time value - 20 years > 0, then timemillis can be assumed. Otherwise uptime is assumed. The reasoning
     *    is, unified logging didn't exist that long ago. The value of 20 has been arbitrarily chosen.
     * 3) There is no reliable way to differentiate the nanosecond timings if only 1 is present. However this may not
     *    matter as GCToolKit would only use these values to create a baseline measure to align date/time with uptime.
     *    This technique is designed to work-around the cases where logs do not contain the uptime decorator.
     * 4) There is no known way to reliably differentiate between PID and TID. At this time, GCToolKit ignores these
     *    decorators.
     *
     * Todo: GCToolkit captures time in the DateTimeStamp class. That class will capture uptime or time or both. If both
     * are missing, GCToolkit JVMEvents will have no sense of time. It is possible that the other timing fields could fill
     * in cases where both the time and uptime decorators were missing.
     * @param line
     */

    private static final Logger LOGGER = Logger.getLogger(Decorators.class.getName());

    // cheap optim, assume that most logs are at info or debug level and thus put those at the head of the list
    private static final List<String> LEVELS = List.of("info", "debug", "error", "warning", "trace", "develop");
    // not the same as UnifiedLoggingTokens.TAGS as there is no literal brackets here
    private static final Pattern TAGS = Pattern.compile("[a-z0-9,. ]+");

    // This is to help differentiate between JVM running time and wall clock time.
    private static final long TWENTY_YEARS_IN_MILLIS = 731L * 24L * 60L * 60L * 1000L;
    private static final long TWENTY_YEARS_IN_NANO = 731L * 24L * 60L * 60L * 1000L;

    private static final int DATE_STAMP_GROUP = 0;
    private static final int UPTIME_GROUP = 1;
    private static final int TIME_MILLIS_OR_MAYBE_UPTIME_MILLIS_GROUP = 2;
    private static final int UPTIME_MILLIS_GROUP = 3;
    private static final int TIME_NANOS_OR_MAYBE_UPTIME_NANOS_GROUP = 4;
    private static final int UPTIME_NANOS_GROUP = 5;
    private static final int PID_GROUP = 6;
    private static final int TID_GROUP = 7;
    private static final int LOG_LEVEL_GROUP = 8;
    private static final int TAGS_GROUP = 9;

    private final String[] decoratorGroups = new String[TAGS_GROUP + 1];
    private int numberOfDecorators;
    private String tags;

    public Decorators(String line) {
        extractValues(line);
    }

    private void extractValues(String line) {
        if (line.charAt(0) != '[') {
            return;
        }
        // don't assign fields until we are done parsing, to avoid inconsistent state
        int numberOfDecorators = 0;
        for (int i = 0; i < line.length() - 1; i++) {
            if (line.charAt(i) == ']') {
                numberOfDecorators++;
                if (line.charAt(i + 1) == ' ') {
                    // end of decorators
                    break;
                }
            }
        }
        if (numberOfDecorators == 0) {
            return;
        }

        int cursor = 0;
        int searchFor = DATE_STAMP_GROUP;
        for (int i = 0; i < numberOfDecorators; i++) {
            int endOfDecorator = line.indexOf(']', cursor);
            if (line.charAt(cursor) != '[' || endOfDecorator == -1) {
                // malformed, exit
                return;
            }
            String currentDecoratorValue = line.substring(cursor + 1, endOfDecorator);
            cursor = endOfDecorator + 1;

            // get a line with all decorators with:
            // java -Xlog:gc+heap=debug:stdout:time,uptime,timemillis,uptimemillis,timenanos,uptimenanos,pid,tid,level,tags -version
            switch (searchFor) {
                case DATE_STAMP_GROUP: // 2025-11-12T23:14:35.406+0100
                {
                    searchFor = UPTIME_GROUP;
                    // check if the first decorator is a date, by checking the expected length
                    if (currentDecoratorValue.length() == 28) {
                        decoratorGroups[DATE_STAMP_GROUP] = currentDecoratorValue;
                        break;
                    }
                    // fallthrough
                }
                case UPTIME_GROUP: // 0.008s
                {
                    searchFor = TIME_MILLIS_OR_MAYBE_UPTIME_MILLIS_GROUP;
                    // there is always 1 integer digit, dot, 3 decimal digits and 's'
                    if (currentDecoratorValue.length() >= 6
                        && currentDecoratorValue.charAt(currentDecoratorValue.length() - 1) == 's'
                        && Character.isDigit(currentDecoratorValue.charAt(currentDecoratorValue.length() - 2))
                        && Character.isDigit(currentDecoratorValue.charAt(currentDecoratorValue.length() - 3))
                        && Character.isDigit(currentDecoratorValue.charAt(currentDecoratorValue.length() - 4))
                        && currentDecoratorValue.charAt(currentDecoratorValue.length() - 5) == '.'
                    ) {
                        currentDecoratorValue = currentDecoratorValue.substring(0, currentDecoratorValue.length() - 1);
                        decoratorGroups[UPTIME_GROUP] = currentDecoratorValue;
                        break;
                    }
                    // fallthrough
                }
                case TIME_MILLIS_OR_MAYBE_UPTIME_MILLIS_GROUP: // 1762985675406ms
                    // fallthrough, as we don't know yet what we are looking for and those are similar in shape
                case UPTIME_MILLIS_GROUP: // 8ms
                {
                    searchFor += 1;
                    if (currentDecoratorValue.length() >= 3
                        && currentDecoratorValue.endsWith("ms")
                        && Character.isDigit(currentDecoratorValue.charAt(currentDecoratorValue.length() - 3))) {
                        int idx = decoratorGroups[TIME_MILLIS_OR_MAYBE_UPTIME_MILLIS_GROUP] == null
                                ? TIME_MILLIS_OR_MAYBE_UPTIME_MILLIS_GROUP
                                : UPTIME_MILLIS_GROUP;
                        decoratorGroups[idx] = currentDecoratorValue;
                        break;
                    }
                    // fallthrough
                }

                case TIME_NANOS_OR_MAYBE_UPTIME_NANOS_GROUP: // 322653519219000ns
                    // fallthrough, same as above
                case UPTIME_NANOS_GROUP: { // 8344208ns
                    searchFor += 1;
                    if (currentDecoratorValue.length() >= 3
                        && currentDecoratorValue.endsWith("ns")
                        && Character.isDigit(currentDecoratorValue.charAt(currentDecoratorValue.length() - 3))) {
                        int idx = decoratorGroups[TIME_NANOS_OR_MAYBE_UPTIME_NANOS_GROUP] == null
                                ? TIME_NANOS_OR_MAYBE_UPTIME_NANOS_GROUP
                                : UPTIME_NANOS_GROUP;
                        decoratorGroups[idx] = currentDecoratorValue;
                        break;
                    }
                    // fallthrough
                }
                case PID_GROUP: // 69050
                    // fallthrough
                case TID_GROUP: // 6147
                {
                    searchFor += 1;
                    if (currentDecoratorValue.chars().allMatch(Character::isDigit)) {
                        int idx = decoratorGroups[PID_GROUP] == null
                                ? PID_GROUP
                                : TID_GROUP;
                        decoratorGroups[idx] = currentDecoratorValue;
                        break;
                    }
                    // fallthrough
                }
                case LOG_LEVEL_GROUP: // debug
                {
                    searchFor = TAGS_GROUP;
                    String trimmed = currentDecoratorValue.trim();
                    if (LEVELS.contains(trimmed)) {
                        decoratorGroups[LOG_LEVEL_GROUP] = trimmed;
                        break;
                    }
                    // fallthrough
                }
                case TAGS_GROUP: // gc,heap
                {
                    String trimmed = currentDecoratorValue.trim();
                    if (TAGS.matcher(trimmed).find()) {
                        decoratorGroups[TAGS_GROUP] = trimmed;
                    }
                    break;
                    // no fallthrough here... :)
                }
                default:
                    // we shouldn't be searching for decorators anymore, so the line is malformed, thus we exit
                    return;
            }
        }
        // now we can assign
        this.numberOfDecorators = numberOfDecorators;
    }

    public ZonedDateTime getDateStamp() {
        try {
            String value = decoratorGroups[DATE_STAMP_GROUP];
            if (value != null) {
                // we know that value has the correct length already, so just check the expected format
                if (
                        value.charAt(4) != '-'
                        || value.charAt(7) != '-'
                        || value.charAt(10) != 'T'
                        || value.charAt(13) != ':'
                        || value.charAt(16) != ':'
                        || value.charAt(19) != '.'
                        || (value.charAt(23) != '+' && value.charAt(23) != '-')) {
                    throw new IllegalArgumentException("Invalid data, should match yyyy-MM-dd'T'HH:mm:ss.SSSZ");
                }
                int year = Integer.parseInt(value, 0, 4, 10);
                int month = Integer.parseInt(value, 5, 7, 10);
                int day = Integer.parseInt(value, 8, 10, 10);
                int hour = Integer.parseInt(value, 11, 13, 10);
                int minute = Integer.parseInt(value, 14, 16, 10);
                int second = Integer.parseInt(value, 17, 19, 10);
                int millis = Integer.parseInt(value, 20, 23, 10);
                char sign = value.charAt(23);
                int hoursOffset = Integer.parseInt(value, 24, 26, 10);
                hoursOffset = sign == '-' ? -hoursOffset : hoursOffset;
                int minutesOffset = Integer.parseInt(value, 26, 28, 10);
                return ZonedDateTime.of(year, month, day, hour, minute, second, millis * 1000 * 1000, ZoneOffset.ofHoursMinutes(hoursOffset, minutesOffset));
            }
        } catch (NullPointerException npe) {
            LOGGER.log(Level.SEVERE, npe.getMessage(), npe);
        }
        return null;
    }

    public double getUpTime() {
        String value = decoratorGroups[UPTIME_GROUP];
        if (value != null) {
            value = value.replace(',', '.');
            return Double.parseDouble(value);
        }
        return -1.0d;
    }

    private long extractClock(int groupIndex, long threshold) {
        long clockReading = -1L;
        String stringValue = decoratorGroups[groupIndex];
        if (stringValue != null) {
            clockReading = Long.parseLong(unboxValue(stringValue, 2));
            if (decoratorGroups[groupIndex + 1] == null)
                if (clockReading < threshold)
                    clockReading = -1L;
        }
        return clockReading;
    }

    public long getTimeMillis() {
        return extractClock(TIME_MILLIS_OR_MAYBE_UPTIME_MILLIS_GROUP, TWENTY_YEARS_IN_MILLIS);
    }

    public long getUptimeMillis() {
        String value = decoratorGroups[UPTIME_MILLIS_GROUP];
        if (value == null) {
            value = decoratorGroups[TIME_MILLIS_OR_MAYBE_UPTIME_MILLIS_GROUP];
        }
        if (value != null) {
            long longValue = Long.parseLong(unboxValue(value, 2));
            if (longValue < TWENTY_YEARS_IN_MILLIS)
                return longValue;
        }
        return -1L;
    }

    public long getTimeNano() {
        return extractClock(TIME_NANOS_OR_MAYBE_UPTIME_NANOS_GROUP, TWENTY_YEARS_IN_NANO);
    }

    public long getUptimeNano() {
        String value = decoratorGroups[UPTIME_NANOS_GROUP];
        if (value == null) {
            value = decoratorGroups[TIME_NANOS_OR_MAYBE_UPTIME_NANOS_GROUP];
        }
        if (value != null) {
            long longValue = Long.parseLong(unboxValue(value, 2));
            if (longValue < TWENTY_YEARS_IN_NANO)
                return longValue;
        }
        return -1L;
    }

    public int getPid() {
        String value = decoratorGroups[PID_GROUP];
        if (value != null) {
            return Integer.parseInt(unboxValue(value));
        }
        return -1;
    }

    public int getTid() {
        String value = decoratorGroups[TID_GROUP];
        if (value != null) {
            return Integer.parseInt(unboxValue(value));
        }
        return -1;
    }

    public Optional<UnifiedLoggingLevel> getLogLevel() {
        String level = decoratorGroups[LOG_LEVEL_GROUP];
        if (level != null)
            try {
                return Optional.of(UnifiedLoggingLevel.valueOf(unboxValue(level)));
            } catch (IllegalArgumentException e) {
                LOGGER.fine("No such debug level: " + level);
                LOGGER.fine(e.getMessage());
                return Optional.empty();
            }
        return Optional.empty();
    }

    public DateTimeStamp getDateTimeStamp() {
        return new DateTimeStamp(getDateStamp(), getUpTime());
    }

    public int getNumberOfDecorators() {
        return numberOfDecorators;
    }

    private String unboxValue(String boxedValue, int postFix) {
        return boxedValue.substring(0, boxedValue.length() - postFix);
    }

    private String unboxValue(String boxedValue) {
        return unboxValue(boxedValue, 0).trim();
    }

    public boolean tagsContain(String tagList) {
        return getTags().contains(tagList);
    }

    public String getTags() {
        if (tags == null && decoratorGroups[TAGS_GROUP] != null) {
            tags = String.join(",", Arrays.asList(
                    unboxValue(decoratorGroups[TAGS_GROUP]).trim().split(",")
            ));
        }
        return tags;
    }
}
